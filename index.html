<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crypto Sniper Enhanced</title>
  <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ3J5cHRvIFNuaXBlciIsInNob3J0X25hbWUiOiJDcnlwdG9TbmlwZXIiLCJzdGFydF91cmwiOiIuLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMxMTExMTEiLCJ0aGVtZV9jb2xvciI6IiMyMjIyMjIiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRJNElpQm9aV2xuYUhROUlqRXlPQ0lpSUhacFpYZENiM2c5SWpBZ01DQXhNamdnTVRJNElpQm1hV3hzUFNJak16TXpJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lQZ284Y21WamRDQjNhV1IwYUQwaU1USTRMQ0FnSUdObGRtbDBhRDBpTVMwd0lHRmpiaTB6SWlCbWFXeHNQU0lqTWpJeUlpOCtQSFJsZUhRZ2VEMGlOalFpSUhrOUlqWTBJaUJtYVd4c1BTSWpSa1pHSWlCbWIyNTBMWE5wZW1VOUlqSTBJaUJtYjI1MExXWmhiV2xzZVQwaWJXOXViM053WVdObElpQjBaWGgwTFdGdVkyaHZjajBpYldsa1pHeGxJajQ4TDJSbFpuTStQQzl6ZG1jKyIsInNpemVzIjoiMTI4eDEyOCIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn1dfQ==">
  <meta name="theme-color" content="#222222">
  <style>
    body { 
      font-family: Arial, sans-serif; 
      background: #111; 
      color: #eee; 
      padding: 10px; 
      margin: 0;
    }
    h1, h2, h3 { text-align: center; }
    .controls, #symbol-selection {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      justify-content: center;
    }
    select, button { 
      margin: 5px; 
      padding: 8px 12px; 
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 4px;
    }
    button {
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #444;
    }
    .coin { 
      padding: 15px; 
      margin-bottom: 10px; 
      background: linear-gradient(135deg, #222, #333); 
      border-radius: 8px; 
      cursor: pointer; 
      border-left: 4px solid #00ff88;
      transition: transform 0.2s;
    }
    .coin.bybit {
      border-left-color: #f7931a;
    }
    .coin.binance {
      border-left-color: #f3ba2f;
    }
    .coin:hover {
      transform: translateX(5px);
    }
    .gain { 
      color: #00ff88; 
      font-weight: bold; 
      font-size: 1.2em;
    }
    .exchange-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .exchange-badge.bybit {
      background: #f7931a;
      color: #000;
    }
    .exchange-badge.binance {
      background: #f3ba2f;
      color: #000;
    }
    .tradingview-link, .exchange-link {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 4px;
      text-decoration: none;
      font-size: 12px;
      margin: 4px 8px 4px 0;
      transition: background 0.3s;
    }
    .tradingview-link {
      background: #1e88e5;
      color: white;
    }
    .tradingview-link:hover {
      background: #1976d2;
    }
    .exchange-link {
      background: #4caf50;
      color: white;
    }
    .exchange-link:hover {
      background: #45a049;
    }
    .exchange-link.binance {
      background: #f3ba2f;
      color: #000;
    }
    .exchange-link.binance:hover {
      background: #d4a027;
    }
    .exchange-link.bybit {
      background: #f7931a;
      color: #000;
    }
    .exchange-link.bybit:hover {
      background: #d97e15;
    }
    .screenshot-note {
      background: #444;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-top: 8px;
      color: #aaa;
    }
    .spam-filter-info {
      background: #2a2a2a;
      padding: 8px;
      border-radius: 4px;
      font-size: 11px;
      margin-top: 8px;
      color: #888;
      border-left: 3px solid #ff6b6b;
    }
    /* Stili per la sezione di selezione simboli */
    #symbol-selection {
      flex-direction: column;
      background: #222;
      padding: 10px;
      border-radius: 8px;
    }
    #exchange-filter {
      text-align: center;
      margin-bottom: 10px;
    }
    details {
      width: 100%;
      background: #333;
      border-radius: 6px;
      margin-bottom: 10px;
      padding: 5px;
    }
    details summary {
      cursor: pointer;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: bold;
      list-style: none;
    }
    details summary::-webkit-details-marker {
      display: none;
    }
    #binance-symbols-list div, #bybit-symbols-list div {
      display: inline-block;
      margin: 3px 6px;
    }
    @media (max-width: 768px) {
      .controls, #symbol-selection {
        flex-direction: column;
        align-items: stretch;
      }
      select, button {
        width: 100%;
        margin: 5px 0;
      }
    }
    .status {
      background: #333;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      text-align: center;
    }
    .status.active {
      background: linear-gradient(90deg, #00ff88, #00cc66);
      color: #000;
    }
  </style>
</head>
<body>
  <h1>ğŸ“ˆ Crypto Sniper Enhanced</h1>
  
  <div class="status" id="status">
    ğŸ”„ Inizializzazione...
  </div>
  
  <div class="controls">
    <label for="timeframe">Timeframe:</label>
    <select id="timeframe">
      <option value="1m">1 Min</option>
      <option value="5m" selected>5 Min</option>
      <option value="30m">30 Min</option>
      <option value="1h">1 Ora</option>
      <option value="4h">4 Ore</option>
      <option value="1d">1 Giorno</option>
      <option value="1w">1 Settimana</option>
      <option value="1M">1 Mese</option>
    </select>
    <button onclick="loadSniper()">ğŸ”„ Ricarica Manuale</button>
    <label><input type="checkbox" id="autoRefresh" checked> Auto Refresh</label>
    <button onclick="requestWakeLock()">ğŸ”’ Mantieni Attivo</button>
    <button onclick="clearSpamFilter()">ğŸ—‘ï¸ Reset Filtro Spam</button>
  </div>
  
  <!-- Sezione di filtro e selezione dei simboli -->
  <div id="symbol-selection">
    <h2>Seleziona Coppie per Analisi</h2>
    <div id="exchange-filter">
      <label>
        <input type="radio" name="exchange-filter" value="all" checked> Tutte
      </label>
      <label>
        <input type="radio" name="exchange-filter" value="binance"> Solo Binance
      </label>
      <label>
        <input type="radio" name="exchange-filter" value="bybit"> Solo Bybit
      </label>
    </div>
    <details id="binance-details" open>
      <summary>
        Binance - Mercato Spot Completo (ordinato per volume)
        <label style="margin-left: 10px;">
          <input type="checkbox" id="select-all-binance"> Seleziona tutto
        </label>
      </summary>
      <div id="binance-symbols-list">
        <!-- Simboli Binance caricati dinamicamente -->
      </div>
    </details>
    <details id="bybit-details" open>
      <summary>
        Bybit - Mercato Spot Completo (ordinato per volume)
        <label style="margin-left: 10px;">
          <input type="checkbox" id="select-all-bybit"> Seleziona tutto
        </label>
      </summary>
      <div id="bybit-symbols-list">
        <!-- Simboli Bybit caricati dinamicamente -->
      </div>
    </details>
    <button onclick="analyzeSelectedSymbols()">Analizza Selezionati</button>
  </div>
  
  <div id="results"></div>

  <script>
    const TELEGRAM_TOKEN = "7919987275:AAGeKy3A-ZtmYm4RZRDEb7MVz6JrOxx95Lc";
    const TELEGRAM_CHAT_ID = "525164223";
    let intervalId = null;
    let wakeLock = null;
    let isRunning = false;
    
    // Funzione per rilevare dispositivi mobili
    function isMobile() {
      return /Mobi|Android|iPhone/i.test(navigator.userAgent);
    }
    
    // Anti-spam system
    let sentAlerts = new Map();

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('data:application/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZXZlbnQgPT4gewogIGNvbnNvbGUubG9nKCdTZXJ2aWNlIFdvcmtlciBpbnN0YWxsZWQnKTsKfSk7CgpzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2YXRlJywgZXZlbnQgPT4gewogIGNvbnNvbGUubG9nKCdTZXJ2aWNlIFdvcmtlciBhY3RpdmF0ZWQnKTsKfSk7');
    }

    function canSendAlert(symbol) {
      const now = Date.now();
      const lastSent = sentAlerts.get(symbol);
      const fourHoursInMs = 4 * 60 * 60 * 1000;
      if (!lastSent || (now - lastSent) > fourHoursInMs) {
        sentAlerts.set(symbol, now);
        return true;
      }
      return false;
    }

    function clearSpamFilter() {
      sentAlerts.clear();
      updateStatus('ğŸ—‘ï¸ Filtro spam resettato - tutti gli alert saranno nuovamente inviati');
      setTimeout(() => updateStatus('âœ… Sistema pronto'), 2000);
    }

    function getTimeUntilNextAlert(symbol) {
      const lastSent = sentAlerts.get(symbol);
      if (!lastSent) return null;
      const now = Date.now();
      const fourHoursInMs = 4 * 60 * 60 * 1000;
      const timeLeft = fourHoursInMs - (now - lastSent);
      if (timeLeft > 0) {
        const hours = Math.floor(timeLeft / (60 * 60 * 1000));
        const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
        return `${hours}h ${minutes}m`;
      }
      return null;
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          updateStatus('ğŸ”’ Wake Lock attivo - schermo mantenuto acceso');
        } else {
          startKeepAliveTimer();
          updateStatus('ğŸ”„ Keep-alive attivato (compatibilitÃ )');
        }
      } catch (err) {
        console.error('Errore wake lock:', err);
        startKeepAliveTimer();
        updateStatus('ğŸ”„ Keep-alive attivato (fallback)');
      }
    }

    function startKeepAliveTimer() {
      setInterval(() => console.log('Keep-alive tick:', new Date().toLocaleTimeString()), 30000);
    }

    function initAudioKeepAlive() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(20000, audioContext.currentTime);
        oscillator.start();
        return true;
      } catch (err) {
        console.error('Audio keep-alive fallito:', err);
        return false;
      }
    }

    function updateStatus(message) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = isRunning ? 'status active' : 'status';
    }

    // RECUPERO SIMBOLI â€“ Ora per l'intero mercato spot

    // Binance: utilizziamo l'endpoint ticker 24hr, senza filtrare per un particolare quote
    async function loadBinanceSymbolList() {
      try {
        const res = await fetch("https://api.binance.com/api/v3/ticker/24hr");
        const data = await res.json();
        // Ordina per quoteVolume (proxy per capitalizzazione)
        data.sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume));
        return data;
      } catch (e) {
        console.error("Errore nel caricamento dei ticker Binance:", e);
        return [];
      }
    }

    // Bybit: recupera tutti i ticker spot
    async function loadBybitSymbolList() {
      try {
        const res = await fetch("https://api.bybit.com/v5/market/tickers?category=spot");
        const data = await res.json();
        if (data.retCode === 0 && data.result && data.result.list) {
          let symbols = data.result.list;
          symbols.sort((a, b) => parseFloat(b.volume24h || 0) - parseFloat(a.volume24h || 0));
          return symbols;
        }
        return [];
      } catch (e) {
        console.error("Errore nel caricamento dei ticker Bybit:", e);
        return [];
      }
    }

    // Popola la sezione di selezione dei simboli
    async function populateSymbolSelection() {
      const binanceContainer = document.getElementById("binance-symbols-list");
      const bybitContainer = document.getElementById("bybit-symbols-list");
      binanceContainer.innerHTML = "<p>Caricamento simboli Binance...</p>";
      bybitContainer.innerHTML = "<p>Caricamento simboli Bybit...</p>";

      const bnSymbols = await loadBinanceSymbolList();
      binanceContainer.innerHTML = "";
      bnSymbols.forEach(item => {
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.name = "binance-symbol";
        checkbox.value = item.symbol;
        checkbox.id = "binance-" + item.symbol;
        const label = document.createElement("label");
        label.htmlFor = checkbox.id;
        label.innerHTML = `${item.symbol} (${parseFloat(item.priceChangePercent).toFixed(2)}%)`;
        const wrapper = document.createElement("div");
        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        binanceContainer.appendChild(wrapper);
      });

      const bySymbols = await loadBybitSymbolList();
      bybitContainer.innerHTML = "";
      bySymbols.forEach(item => {
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.name = "bybit-symbol";
        checkbox.value = item.symbol;
        checkbox.id = "bybit-" + item.symbol;
        const label = document.createElement("label");
        label.htmlFor = checkbox.id;
        const pct = item.price24hPcnt ? parseFloat(item.price24hPcnt * 100).toFixed(2) : "0.00";
        label.innerHTML = `${item.symbol} (${pct}%)`;
        const wrapper = document.createElement("div");
        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        bybitContainer.appendChild(wrapper);
      });
    }

    // Funzione per creare URL TradingView
    function getTradingViewInterval(interval) {
      const intervalMap = {
        '1m': '1',
        '5m': '5',
        '15m': '15',
        '30m': '30',
        '1h': '60',
        '4h': '240',
        '1d': '1D',
        '1w': '1W',
        '1M': '1M'
      };
      return intervalMap[interval] || '5';
    }

    function createTradingViewUrl(symbol, interval, exchange = 'BINANCE') {
      const tvInterval = getTradingViewInterval(interval);
      return `https://www.tradingview.com/chart/?symbol=${exchange}:${symbol}&interval=${tvInterval}&theme=dark`;
    }

    // Funzione per creare link agli exchange (deep linking in mobile se supportato)
    function createExchangeUrl(symbol, exchange) {
      if (exchange.toLowerCase() === 'binance') {
        const baseAsset = symbol.replace("USDC", "");  // Per Binance questo potrebbe variare; qui viene lasciato il replace se presente
        if(isMobile()){
          return `binance://trade?market=${baseAsset}_USDC`;
        }
        return `https://www.binance.com/en/trade/${baseAsset}_USDC`;
      } else if (exchange.toLowerCase() === 'bybit') {
        if(isMobile()){
          return `bybit://trade/spot?symbol=${symbol}`;
        }
        return `https://www.bybit.com/en/trade/spot/${symbol}`;
      }
      return '#';
    }

    // BINANCE - Analisi candele (utilizza il simbolo passato)
    async function getBinanceMaxGain(symbol, tf) {
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=6`);
        const data = await res.json();
        if (!data || data.length < 6) return null;
        let maxGain = -Infinity;
        let bestCandle = null;
        for (let i = 1; i <= 5; i++) {
          const open = parseFloat(data[i][1]);
          const close = parseFloat(data[i][4]);
          const gain = ((close - open) / open) * 100;
          if (gain > maxGain) {
            maxGain = gain;
            bestCandle = {
              symbol,
              exchange: 'binance',
              gain: gain.toFixed(2),
              open,
              close,
              index: i,
              timestamp: new Date(data[i][0]).toLocaleTimeString(),
              tradingViewUrl: createTradingViewUrl(symbol, tf, 'BINANCE'),
              exchangeUrl: createExchangeUrl(symbol, 'binance')
            };
          }
        }
        if (maxGain >= 3) {
          if (canSendAlert(symbol)) {
            sendTelegramAlert(bestCandle, tf);
          }
          return bestCandle;
        } else {
          return null;
        }
      } catch (e) {
        console.error('Errore Binance per', symbol, ':', e);
        return null;
      }
    }

    // BYBIT - Analisi candele (utilizza il simbolo passato)
    async function getBybitMaxGain(symbol, tf) {
      try {
        const bybitInterval = getTradingViewInterval(tf).toLowerCase();
        const res = await fetch(`https://api.bybit.com/v5/market/kline?category=spot&symbol=${symbol}&interval=${bybitInterval}&limit=6`);
        const data = await res.json();
        if (data.retCode !== 0 || !data.result || !data.result.list || data.result.list.length < 6) {
          return null;
        }
        let maxGain = -Infinity;
        let bestCandle = null;
        const klines = data.result.list.reverse();
        for (let i = 1; i <= 5; i++) {
          const open = parseFloat(klines[i][1]);
          const close = parseFloat(klines[i][4]);
          const gain = ((close - open) / open) * 100;
          if (gain > maxGain) {
            maxGain = gain;
            bestCandle = {
              symbol,
              exchange: 'bybit',
              gain: gain.toFixed(2),
              open,
              close,
              index: i,
              timestamp: new Date(parseInt(klines[i][0])).toLocaleTimeString(),
              tradingViewUrl: createTradingViewUrl(symbol, tf, 'BYBIT'),
              exchangeUrl: createExchangeUrl(symbol, 'bybit')
            };
          }
        }
        if (maxGain >= 3) {
          if (canSendAlert(`BYBIT_${symbol}`)) {
            sendTelegramAlert(bestCandle, tf);
          }
          return bestCandle;
        } else {
          return null;
        }
      } catch (e) {
        console.error('Errore Bybit per', symbol, ':', e);
        return null;
      }
    }

    async function sendTelegramAlert(data, tf) {
      const exchangeIcon = data.exchange === 'bybit' ? 'ğŸŸ ' : 'ğŸŸ¡';
      const exchangeName = data.exchange === 'bybit' ? 'BYBIT' : 'BINANCE';
      const quoteCurrency = data.exchange === 'bybit' ? 'USDT' : 'USDC';
      const message = `ğŸš¨ CRYPTO SNIPER ALERT ğŸš¨\n\n${exchangeIcon} Exchange: ${exchangeName}\nğŸ”¸ Coin: ${data.symbol}\nğŸ’° Quote: ${quoteCurrency}\nğŸ”¸ Timeframe: ${tf}\nğŸ”¸ Gain: ${data.gain}%\nğŸ•’ Candela nÂ° ${data.index + 1}\nğŸŸ¢ Open: ${data.open}\nğŸ”´ Close: ${data.close}\nâ° Timestamp: ${data.timestamp}\n\nğŸ“Š TradingView: ${data.tradingViewUrl}\nğŸ”— ${exchangeName} Trading: ${data.exchangeUrl}\n\nğŸ’¡ Suggerimento: TradingView si apre in modalitÃ  completa per analisi avanzata.`;
      const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
      try {
        await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ 
            chat_id: TELEGRAM_CHAT_ID, 
            text: message,
            parse_mode: 'HTML',
            disable_web_page_preview: false
          })
        });
        console.log(`Alert inviato per ${exchangeName}:${data.symbol}`);
      } catch (err) {
        console.error('Errore invio Telegram:', err);
      }
    }

    // Funzione di scansione automatica (analizza tutte le coppie con gain > 3%)
    async function loadSniper() {
      const tf = document.getElementById("timeframe").value;
      const container = document.getElementById("results");
      isRunning = true;
      updateStatus(`ğŸ”„ Scansione in corso... (${tf})`);
      container.innerHTML = "â³ Scansione mercato multi-exchange...";
      try {
        const [binanceSymbols, bybitSymbols] = await Promise.all([
          getBinanceSymbolListForSniper(),
          getBybitSymbolListForSniper()
        ]);
        console.log(`Trovati ${binanceSymbols.length} simboli Binance e ${bybitSymbols.length} simboli Bybit`);
        const results = [];
        let processed = 0;
        const totalSymbols = Math.min(binanceSymbols.length, 75) + Math.min(bybitSymbols.length, 75);
        for (const symbol of binanceSymbols.slice(0, 75)) {
          const data = await getBinanceMaxGain(symbol, tf);
          if (data) results.push(data);
          processed++;
          if (processed % 20 === 0) updateStatus(`ğŸ”„ Processate ${processed}/${totalSymbols} coppie...`);
          await new Promise(r => setTimeout(r, 60));
        }
        for (const symbol of bybitSymbols.slice(0, 75)) {
          const data = await getBybitMaxGain(symbol, tf);
          if (data) results.push(data);
          processed++;
          if (processed % 20 === 0) updateStatus(`ğŸ”„ Processate ${processed}/${totalSymbols} coppie...`);
          await new Promise(r => setTimeout(r, 100));
        }
        results.sort((a, b) => b.gain - a.gain);
        container.innerHTML = "";
        if (results.length === 0) {
          container.innerHTML = '<div class="coin">ğŸ“Š Nessuna coin con gain superiore al 3% trovata in questo momento</div>';
          updateStatus('âœ… Scansione completata - Nessun gain > 3%');
        } else {
          updateStatus(`âœ… Trovate ${results.length} coin con gain > 3%!`);
          results.forEach(r => {
            const el = document.createElement("div");
            el.className = `coin ${r.exchange}`;
            el.innerHTML = `
              <div class="exchange-badge ${r.exchange}">${r.exchange.toUpperCase()}</div>
              <div><strong>ğŸ’° ${r.symbol}</strong> ${r.exchange === 'bybit' ? '' : ''}</div>
              <div>ğŸ“Š Massimo Gain: <span class="gain">+${r.gain}%</span></div>
              <div>ğŸ•’ Candela nÂ° ${r.index + 1} | â° ${r.timestamp}</div>
              <div>ğŸŸ¢ Open: ${r.open} | ğŸ”´ Close: ${r.close}</div>
              <div style="margin-top: 10px;">
                <a href="${r.tradingViewUrl}" target="_blank" class="tradingview-link">ğŸ“Š TradingView</a>
                <a href="${r.exchangeUrl}" target="_blank" class="exchange-link ${r.exchange}">
                  ğŸ”— ${r.exchange.toUpperCase()} Trading
                </a>
              </div>
              <div class="screenshot-note">
                ğŸ’¡ <strong>Links:</strong> TradingView si apre in modalitÃ  completa per analisi avanzata.
              </div>
            `;
            el.addEventListener("click", (e) => {
              if (e.target.tagName !== 'A') {
                window.open(createTradingViewUrl(r.symbol, '1d', r.exchange.toUpperCase()), '_blank');
              }
            });
            container.appendChild(el);
          });
        }
      } catch (error) {
        console.error('Errore durante la scansione:', error);
        updateStatus('âŒ Errore durante la scansione');
        container.innerHTML = '<div class="coin">âŒ Errore durante la scansione del mercato</div>';
      }
      isRunning = false;
    }

    async function getBinanceSymbolListForSniper() {
      try {
        const res = await fetch("https://api.binance.com/api/v3/exchangeInfo");
        const data = await res.json();
        return data.symbols.filter(s => s.status === "TRADING").map(s => s.symbol);
      } catch (e) {
        console.error("Errore ciclo Binance per sniper:", e);
        return [];
      }
    }
    
    async function getBybitSymbolListForSniper() {
      try {
        const res = await fetch("https://api.bybit.com/v5/market/instruments-info?category=spot");
        const data = await res.json();
        if (data.retCode === 0 && data.result && data.result.list) {
          return data.result.list.filter(s => s.status === "Trading").map(s => s.symbol);
        }
        return [];
      } catch (error) {
        console.error('Errore ciclo Bybit per sniper:', error);
        return [];
      }
    }

    async function analyzeSelectedSymbols() {
      const tf = document.getElementById("timeframe").value;
      const container = document.getElementById("results");
      isRunning = true;
      updateStatus(`ğŸ”„ Analisi selezionata in corso... (${tf})`);
      container.innerHTML = "â³ Analisi delle coppie selezionate...";
      let selectedBinance = [];
      let selectedBybit = [];
      document.querySelectorAll('input[name="binance-symbol"]:checked').forEach(el => selectedBinance.push(el.value));
      document.querySelectorAll('input[name="bybit-symbol"]:checked').forEach(el => selectedBybit.push(el.value));
      const results = [];
      let processed = 0;
      const totalSymbols = selectedBinance.length + selectedBybit.length;
      for (const symbol of selectedBinance) {
        const data = await getBinanceMaxGain(symbol, tf);
        if (data) results.push(data);
        processed++;
        if (processed % 20 === 0) updateStatus(`ğŸ”„ Processate ${processed}/${totalSymbols} coppie...`);
        await new Promise(r => setTimeout(r, 60));
      }
      for (const symbol of selectedBybit) {
        const data = await getBybitMaxGain(symbol, tf);
        if (data) results.push(data);
        processed++;
        if (processed % 20 === 0) updateStatus(`ğŸ”„ Processate ${processed}/${totalSymbols} coppie...`);
        await new Promise(r => setTimeout(r, 100));
      }
      results.sort((a, b) => b.gain - a.gain);
      container.innerHTML = "";
      if (results.length === 0) {
        container.innerHTML = '<div class="coin">ğŸ“Š Nessuna coin con gain superiore al 3% trovata per le coppie selezionate</div>';
        updateStatus('âœ… Analisi completata - Nessun gain > 3%');
      } else {
        updateStatus(`âœ… Trovate ${results.length} coin con gain > 3% nelle coppie selezionate!`);
        results.forEach(r => {
          const el = document.createElement("div");
          el.className = `coin ${r.exchange}`;
          el.innerHTML = `
            <div class="exchange-badge ${r.exchange}">${r.exchange.toUpperCase()}</div>
            <div><strong>ğŸ’° ${r.symbol}</strong> ${r.exchange === 'bybit' ? '' : ''}</div>
            <div>ğŸ“Š Massimo Gain: <span class="gain">+${r.gain}%</span></div>
            <div>ğŸ•’ Candela nÂ° ${r.index + 1} | â° ${r.timestamp}</div>
            <div>ğŸŸ¢ Open: ${r.open} | ğŸ”´ Close: ${r.close}</div>
            <div style="margin-top: 10px;">
              <a href="${createTradingViewUrl(r.symbol, '1d', r.exchange.toUpperCase())}" target="_blank" class="tradingview-link">ğŸ“Š TradingView</a>
              <a href="${r.exchangeUrl}" target="_blank" class="exchange-link ${r.exchange}">
                ğŸ”— ${r.exchange.toUpperCase()} Trading
              </a>
            </div>
            <div class="screenshot-note">
              ğŸ’¡ <strong>Links:</strong> TradingView si apre in modalitÃ  completa per analisi avanzata.
            </div>
          `;
          el.addEventListener("click", (e) => {
            if (e.target.tagName !== 'A') {
              window.open(createTradingViewUrl(r.symbol, '1d', r.exchange.toUpperCase()), '_blank');
            }
          });
          container.appendChild(el);
        });
      }
      isRunning = false;
    }

    // Event listeners
    document.getElementById("timeframe").addEventListener("change", loadSniper);
    document.getElementById("autoRefresh").addEventListener("change", function () {
      if (this.checked) {
        intervalId = setInterval(loadSniper, 60000);
        updateStatus('ğŸ”„ Auto refresh attivato (60s)');
      } else {
        clearInterval(intervalId);
        updateStatus('â¸ï¸ Auto refresh disattivato');
      }
    });

    document.querySelectorAll('input[name="exchange-filter"]').forEach(radio => {
      radio.addEventListener("change", function(){
        if (this.value === "all") {
          document.getElementById("binance-details").style.display = "";
          document.getElementById("bybit-details").style.display = "";
        } else if (this.value === "binance") {
          document.getElementById("binance-details").style.display = "";
          document.getElementById("bybit-details").style.display = "none";
        } else if (this.value === "bybit") {
          document.getElementById("binance-details").style.display = "none";
          document.getElementById("bybit-details").style.display = "";
        }
      });
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.log('App in background');
      } else {
        console.log('App in foreground');
        if (wakeLock === null) {
          requestWakeLock();
        }
      }
    });

    loadSniper();
    intervalId = setInterval(loadSniper, 60000);
    updateStatus('ğŸš€ Crypto Sniper Enhanced avviato');
    setTimeout(() => {
      requestWakeLock();
      initAudioKeepAlive();
    }, 2000);
    populateSymbolSelection();
  </script>
</body>
</html>
